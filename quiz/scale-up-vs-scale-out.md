---
layout  : wiki
title   : 
summary : 
date    : 2022-08-23 20:44:05 +0900
updated : 2022-08-30 21:41:10 +0900
tags    : 
toc     : true
public  : true
parent  : 
latex   : false
---
* TOC
{:toc}

# 퀴즈: 스케일 업, 스케일 아웃을 적용하는 상황

서비스 출시 후 사용자가 늘어나는 상황을 생각해보자. 사용자가 많아지면 그만큼 저장해야 할 데이터도 많아져 기존 용량이 부족해질 수 있다. 또 동시접속하는 사용자가 많아져서 기존 서버 성능으로는 서비스가 원활하게 돌아가기 어려운 상황이 발생할 수 있다.
scale out과 scale up은 이런 상황에서 인프라를 업그레이드하는 방법이다.
스케일 업은 디스크 추가, CPU/메모리 업그레이드 등을 통해 서버의 성능을 높이는 것이다. 스케일 아웃은 서비스에 쓰고 있는 서버와 비슷한 사양의 서버를 추가해 연결하는 것이다.
스케일 업은 인프라 업그레이드 후에도 서버의 수가 동일하다. 따라서 서버가 받는 부하가 동일하다. 하지만 장애가 발생할 경우 영향이 크다. 대신할 수 있는 서버가 스케일 아웃에 비해 비교적 적을 가능성이 높기 때문이다.
스케일 아웃은 서버의 수가 늘어나므로 기존 서버가 받던 부하를 추가된 서버와 나눠서 받게 되어 부하가 낮아진다. 장애가 생기더라도 서버 여러 대가 있으므로 서버 전체가 장애날 가능성이 스케일 업에 비해 비교적 적다.

scale out vs scale up 선택 기준
스케일 아웃과 스케일 업을 선택할 때 고려할 점을 알아봤습니다.

정합성
– 스케일 아웃은 모든 서버의 데이터를 일치시켜야 하는 데이터 정합성 문제를 해결해야 합니다. 데이터가 서버 여러 대에 걸쳐 저장되어 있다면 해당 서버 모두에서 일치하도록 해주어야 합니다. 데이터 갱신이 빈번하게 일어날 경우 이와 같은 정합성 유지가 어려워집니다.
– 스케일 업은 서버 한 대에 모든 데이터가 저장되므로 데이터 정합성이 보장됩니다.

확장성
– 스케일 업은 기존 장비를 바꾸기 때문에 한 번 스케일 업 하면 되돌리기 어렵습니다.
– 스케일 업은 향후 확장 가능성을 대비해 서버를 현재 성능보다 다소 높은 서버로 업그레이드하는 경우가 많습니다. 만약 예측했던 만큼의 성능이 필요한 때가 없다면 손해입니다. 실제 필요한 정도의 성능과 이미 확장해놓은 성능의 차이만큼 손해가 생기기 때문입니다.
– 스케일 업으로 성능을 무한정 업그레이드할 수는 없습니다.
– 스케일 아웃은 유연하게 확장할 수 있습니다. 서버를 추가하거나 줄여서 필요에 맞게 성능을 높이거나 줄일 수 있습니다.

다운타임
– 스케일 업은 장비를 바꿔서 데이터를 옮기는 동안 다운타임이 생길 수 있고, 데이터 일부를 잃게될 수도 있습니다.
– 스케일 아웃은 장비를 바꾸지 않고 추가하기 때문에 다운타임 없이 데이터를 빠르게 옮길 수 있습니다.

트래픽
– 스케일 아웃을 적용하면 여러대의 서버가 생기게 됨에 따라 각 서버에 적절히 트래픽을 분배하기 위해 로드 밸런싱을 적용해야 합니다. 반면 스케일 업은 한 서버가 트래픽을 감당하므로 트래픽 분배를 신경쓰지 않아도 괜찮습니다.

scale out 시 세션 불일치 현상은 왜 발생하고, 이를 해결하기 위한 방법으로는 무엇이 있는지

세션 불일치 현상의 원인

스케일 아웃 방식으로 서버를 확장하면 트래픽을 각 서버에 분산시키는 로드 밸런서가 필요합니다. 로드 밸런서는 클라이언트마다 어떤 서버를 이용하게 할지 정해줍니다.
1) 클라이언트가 서버로 요청을 보내면 로드 밸런서는 여러 서버 중 하나에 이 요청을 전달합니다. 이 서버를 서버 A라고 하겠습니다.
2) 요청을 전달받은 서버 A는 클라이언트에 세션 아이디를 발급합니다. 이 세션 정보는 서버 A를 제외한 다른 서버는 알지 못합니다.
3) 같은 클라이언트가 다음에 요청을 보냈을 때 로드 밸런서가 서버 A가 아닌 다른 서버, 예를 들어 서버 B로 요청을 보낸다면, 서버 B는 클라이언트의 세션 정보를 가지고 있지 않기 때문에 세션 정보를 다시 생성해야 합니다.
위와 같은 상황에서 세션 불일치가 발생합니다.

세션 불일치를 해결하기 위한 방법
I. Sticky session
작동 방식
1) 특정 사용자가 접속을 시도했을 때 처음 접속된 서버로 계속해서 접속하도록 트래픽을 처리합니다.
2) 로드 밸런서가 라운드 로빈 방식으로 트래픽을 분산합니다. 예를 들어 브라우저 a가 서버 A에 세션을 생성하면 로드 밸런서는 이후 브라우저 a가 보내는 모든 요청을 서버 A로 리다이렉트합니다. 이렇게 하면 브라우저 a는 고정된 세션만 사용하게 됩니다.
단점
– 브라우저마다 매칭할 서버가 고정되어 있기 때문에 어느 한 서버에 트래픽이 집중되어 있더라도 브라우저는 서버를 바꿔 이용할 수 없습니다.
– 서비스 중 서버에 장애가 생기면 그 서버를 쓰는 브라우저는 세션 정보를 잃어버립니다.

II. Session clustering
작동 방식
– 여러 대의 컴퓨터가 하나의 시스템처럼 동작하도록 합니다.
– 브라우저의 로그인 정보를 모든 서버에 복제해서 만약 한 서버에 문제가 생기더라도 동일한 세션 아이디로 다른 서버와 매칭할 수 있습니다.
단점
– 모든 서버가 동일한 정보를 복제해서 가지고 있어야 하므로 메모리가 많이 필요합니다.
– 세션이 저장소에 저장될 때마다 모든 서버에 입력되는데, 한꺼번에 많이 입력되면 성능 저하가 발생할 위험이 있습니다.

III. 별도의 세션 저장소
– 기존 서버가 갖고 있는 세션 저장소를 이용하는 것이 아니라, 세션만 저장할 별도의 세션 저장소를 사용합니다.
– 저장소는 메모리에 둘 수도, 디스크에 둘 수도 있습니다.
– Inmemory DB란 데이터 스토리지의 메인 메모리에 설치되어 운영되는 방식의 데이터베이스 시스템입니다.
– 메모리 접근은 여러 장점을 갖습니다.
1) 디스크 접근보다 빠르다.
2) 내부 최적화 알고리즘이 더 단순하며 더 적은 CPU 명령을 실행한다.
3) 메모리의 데이터에 접근하면 데이터를 조회할 때 검색 시간이 줄어든다.
– 메모리는 휘발성이기에 DB서버 전원이 꺼진다면 자료들이 삭제됩니다.
– 이때문에 로그인 세션 같은, 서버가 꺼져도 상관없는 임시 데이터를 주로 사용합니다.
– DB가 재구동될 때 디스크로부터 로그 파일을 읽어와 DBMS 구조를 재구축하는 방법을 써서 휘발성 때문에 생기는 단점을 보완하기도 합니다.

#### Disk-Based DB
Mysql, PostgreSQL, MongoDB 등이 여기 속합니다.
I/O 속도가 느립니다.
전원이 꺼지더라도 데이터가 날아가지 않습니다.

참고 자료
스케일 업, 스케일 아웃
https://m.blog.naver.com/islove8587/220548900044
https://www.weka.io/learn/scale-up-vs-scale-out/
세션 불일치
https://junghyungil.tistory.com/163?category=900222
https://junshock5.tistory.com/84
https://hamryt.tistory.com/4
https://liasn.tistory.com/3
https://hudi.blog/session-consistency-issue/
